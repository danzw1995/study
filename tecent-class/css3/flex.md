
 弹性盒子
 box/inline-box (老的写法)

 flex/inline-flex(新的写法)

1. 给一个元素的display 属性设上 flex / inline-flex时，可以在在元素内部，按照弹性盒子的规则进行布局。该元素可以称之为容器，其子元素为项目

2. 容器的属性
   a. flex-direction: 定义主轴的方向，弹性盒子内部的项目将按照主轴的方向进行排列，
    ①：row（默认值）         水平方向，从左至右
    ②：row-reverse          水平方向，从右至左
    ③：column               垂直方向，从上到下
    ④：column-reverse       垂直方向，从下到上

    弹性盒子除了有主轴之外，还有一个交叉轴，当主轴是水平方向的时候，交叉轴为垂直方向，反之。
    
    b. justify-content  定义主轴方向上的对齐方式
      ①：flex-start（默认值）   弹性盒子元素向行起始位置对齐。该行的第一个子元素的主起始位置的边界与该行的主起始边界对齐，后续的项目与前一个项目对齐
      ②：flex-end     弹性盒子元素向行结束位置对齐。该行的最后一个子元素的主结束位置的边界与该行的主结束边界对齐，前面的项目与后一个项目对齐
      ③: center       弹性盒子元素向行中间位置对齐。该行的子元素相互对齐并在行中居中对齐，同时第一个子元素与该行的主起始位置的边距等于最后一个子元素与该行的主结束位置的边距（如果剩余空间是负数，则保持左右溢出的长度一致）
      ④：space-between  弹性盒子平均的分配在行里。该行的第一个子元素边界与该行的主起始边界对齐，最后一个子元素的边界与该行的主结束边界对齐。子元素和子元素之间的间隙保持相等（如果该行只有一个子元素或者剩余空间为负值，则效果和flex-start一致）
      ⑤：space-around   弹性盒子平均的分配在行里。该行的第一个子元素与该行的主起始边界的距离/最后一个子元素与该行的主结束边界的距离 等于子元素和子元素之间的距离的一般（如果该行只有一个子元素，或者剩余空间为负值，则效果和center 一致）

    c. align-items 定义项目在交叉轴方向上的对齐方式
      ①：flex-start   项目和交叉轴的起点边界对齐
      ②：flex-end     项目和交叉轴的结束边界对齐
      ③：center       项目置于交叉轴的中间
      ④：baseline     项目与第一行的文字基线对齐
      ⑤：stretch（默认值） 如果没有指定交叉轴方向上的长度，那么将采用stretch的规则，即会将元素的边距盒尺寸尽可能接近该行的尺寸

    d. align-content 定义项目在交叉轴上的对齐方式（只有在多行情况下才有效果，单行无效）, 具体描述和justify-content 差不多
    如果从行的角度来理解，就不存在什么单行无效的问题了，具体解释看下面
      ①：flex-start
      ②：flex-end
      ③：center
      ④：space-between
      ⑤：sapce-around
      ⑥：stretch（默认值）

    我的理解： align-items 和align-content;
      align-items 可以在单行或者单行中使用，是在该行中进行交叉轴上的对齐.是相对于该行来进行处理
      align-content 需要在有多行的情况下使用，是将所有项目相对于容器来进行处理。此时行在交叉轴方向上的长度为该行项目在交叉轴方向上的最大长度
      可以理解为行相对于容器在交叉轴上的对齐方式

      补充一点，但仅仅是我的理解。
      关于行在交叉轴上的长度问题
      行在交叉轴上的长度 = 该行项目在交叉轴上最大的长度 + （容器在交叉轴的长度 - 每行项目在交叉轴上的最大值的和）/ 行数
      如果每行项目在交叉轴上的最大值的和大于容器在交叉轴上的长度，则该行在交叉轴上的长度即为该行在交叉轴上最大的长度
      如果只有一行，则行在交叉轴上的长度 = 容器在交叉轴上的长度
      注意：项目在交叉轴上的长度 是margin-box 区域的长度。而且项目与项目之间不会发生margin合并现象

    e: flex-wrap 定义是否换行
      ①：nowrap（默认值）所有的项目都在一行显示
      ②：wrap 当容器在主轴方向上不能再容纳项目时，会换行
      ③：wrap-reverse 反转wrap 排列
    f: flex-flow: flex-direction flex-wrap 的复合写法
  
3. 项目的属性
    a. flex-grow: 根据扩展因子的比例来分配剩余的空间，默认值为0，忽略负值。每个项目分配的空间为 当前项目的扩展因子 * 剩余的空间/ 该行所有项目的扩展因子和 
    b. flex-shrink: 根据压缩因子的比例压缩溢出的空间，默认值为1。其计算公式和扩展有区别。
      当前项目压缩的长度 = （当前项目的内容区长度 * 压缩因子 / 总计算值） * 溢出的空间
      总计算值 = （项目的内容区长度 * 压缩因子）的和
      注意：压缩的长度最大为项目内容区的长度。如果当前项目压缩的长度大于了当前项目内容区的长度，那么将该项目的内容区的长度置为0（前提是项目是没有内容，如果有内容，内容指的是文字，图片，则长度为内容的长度。可以理解为将该项目作为内联块元素inline-block来计算长度），同时不将当前项目计算在总计算值中。
    c. flex-basis 设置项目基准值
      ①：auto：无特性宽度，取决于其他值
      ②：length：具体长度
      ③: percent：百分比
      ④：content 基于内容自动计算（目前不兼容）
      注意：如果同时制定了flex-basis 和width，那么应用flex-basis的宽度为项目的宽度（注意是box-sizing 下的宽度，不一定等于内容区的宽度）,
      width的值为内容区的上限，flex-basis 为内容区的下限
      正常情况下 flex-basis <= 项目内容区的长度 <= width
    d. order: 定义项目的排列顺序，值小的在前面, 可以为负值，默认值为0，其效果和z-index 类似，只是体现在平面上，也就是说，如果两个项目有重叠的部分，order值大的会在上面，order值小的会在下面（前提在没有定位的情况下）。感觉z-index 这个知识点 还要再探讨探讨
    e. align-self 定义项目在交叉轴上的对齐方式,效果和 align-items类似
      ①：flex-start
      ②：flex-end
      ③：center
      ④：auto （默认值）如果有父元素，则继承父元素的align-items 值，没有则为'stretch'
      ⑤：stretch
      ⑥：baseline
    注意：当容器使用了align-items, 项目使用了 align-self时， 以align-self为准，即 align-self 的优先级大于align-items;
    f. flex    flex-grow | flex-shrink | flex-basis 的复合值
